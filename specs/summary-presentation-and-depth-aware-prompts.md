# Summary Presentation & Depth-Aware Prompts

**Status:** Ready for implementation  
**Date:** 2026-02-19  
**Scope:** lossless-claw plugin (TypeScript) — schema, assembly, and summarization  
**Prerequisite:** TUI prompts (already implemented in lcm-tui)

## Problem

Three interconnected issues with how LCM summaries serve the consuming model:

### 1. Poor presentation format

Summaries are injected into context as informal text blocks:

```
[Summary ID: sum_1147c2cc5dd791d0]
[Parent Summaries: sum_f8ee4e7a5a7b7090, sum_2930f2aaa92f4839]

# LCM System Development Arc
...content...
```

Problems:
- No closing delimiter — unclear where one summary ends and the next begins
- Metadata (ID, parents) looks like content, not structured metadata
- No time range, depth, or descendant count — the model can't assess how much
  information is compressed beneath a given summary
- The model treats summaries as complete information rather than navigation aids
  that point to expandable detail

### 2. No expansion cues

The model reads a summary and assumes it has the full picture. There's no signal
that says "this is lossy — here's what was dropped and how to recover it." The
`lcm_expand_query` tool exists but the model lacks contextual triggers to use it.

### 3. One-size-fits-all condensed prompts

The plugin uses a single Pi-style template for all condensed summaries regardless
of depth. The result: rigid status reports with identical section headers that
waste tokens on structure rather than information. Leaf summaries also lack
timestamp injection, so the summarizer can't produce timeline-oriented output
even when instructed to.

## Design

### XML summary presentation

Replace the informal `[Summary ID: ...]` format with structured XML tags:

```xml
<summary id="sum_1147c2cc5dd791d0" range="2026-02-17 07:37–17:21 PST" depth="2" descendants="45">
Content of the summary goes here. Plain text, organized however makes sense
for the content. No mandatory template structure.

Expand for details about: exact config values, specific error messages,
step-by-step debugging sequences, individual worker implementations
</summary>
```

**Attributes:**

| Attribute | Source | Purpose |
|-----------|--------|---------|
| `id` | `summary.summaryId` | Target for `lcm_expand_query(summaryIds: [...])` |
| `range` | `summary.earliestAt` – `summary.latestAt` | Time span covered (replaces in-content timelines) |
| `depth` | `summary.depth` | Compression layers (0=leaf, 1=d1, etc.) |
| `descendants` | `summary.descendantCount` | Total sub-nodes — signals information density |

**Why XML:** Models parse XML attributes reliably. The closing `</summary>` tag
creates an unambiguous boundary between consecutive summaries. Attributes separate
metadata from content cleanly, reducing both token waste and confusion about what's
structural vs. informational.

**Token impact:** Each summary gains ~30-40 tokens of XML wrapper. But this is
offset by: (a) removing in-content timeline repetition from prompts, (b) removing
the `[Summary ID: ...]` and `[Parent Summaries: ...]` headers, (c) the model
making better use of `lcm_expand_query` instead of generating vague answers from
lossy summaries.

### "Expand for details about:" footer

Each summary includes a closing line listing the categories of information that
were compressed away. This is generated by the summarizer (instructed via prompt),
not computed mechanically.

Examples by depth:
- **d0 (leaf):** `Expand for details about: exact commands run, full error output, tool call sequences`
- **d1:** `Expand for details about: per-message debugging steps, specific config values, commit details`
- **d2:** `Expand for details about: individual session workflows, worker-level implementation details, intermediate decision rationale`
- **d3+:** `Expand for details about: session timelines, specific technical implementations, detailed decision histories`

The footer is part of the summary content (generated by the model during
summarization), not appended mechanically. The prompt instructs the model to
include it.

### Schema additions

Add three columns to the `summaries` table:

```sql
ALTER TABLE summaries ADD COLUMN earliest_at TEXT;
ALTER TABLE summaries ADD COLUMN latest_at TEXT;
ALTER TABLE summaries ADD COLUMN descendant_count INTEGER NOT NULL DEFAULT 0;
```

**Population:**

For **leaf summaries** (created in `leafPass`):
- `earliest_at` = `MIN(messages.created_at)` of source messages
- `latest_at` = `MAX(messages.created_at)` of source messages
- `descendant_count` = 0 (leaves have no children)

For **condensed summaries** (created in `condensedPass`):
- `earliest_at` = `MIN(children.earliest_at)` of absorbed child summaries
- `latest_at` = `MAX(children.latest_at)` of absorbed child summaries
- `descendant_count` = `SUM(children.descendant_count + 1)` for each child
  (each child counts as 1, plus all its descendants)

**Backfill migration:** On startup, compute values for existing summaries:
1. For leaves: query `summary_messages` → `messages.created_at` to derive range
2. For condensed (bottom-up by depth): query `summary_parents` → child summary
   `earliest_at`/`latest_at`/`descendant_count` to derive values
3. Summaries without linked messages (orphans) get `created_at` as fallback

### Depth-aware summarization prompts

Replace the single `buildCondensedSummaryPrompt` with depth-dispatched variants.
Port the TUI's Go `text/template` prompts to TypeScript string interpolation.

#### Prompt changes summary

| Prompt | Key changes from current |
|--------|--------------------------|
| **Leaf** | Add timestamp injection to source text. Add "expansion footer" instruction. Remove rigid section requirements ("Goals & Context", etc.). |
| **d1 condensed** | Replace Pi-style template with narrative/chronological format. Reference `previous_context` for delta compression. Instruct "expand for details about:" footer. Relax timeline — timestamps exist in the XML `range` attribute; only mention sequence/causality in content. |
| **d2 condensed** | Arc extraction focus. No previous_context (d2+ don't use it). Relax timeline further — date headers in the XML attribute handle "when." Instruct footer. |
| **d3+ condensed** | Cold-start orientation. Ruthlessly concise. "What would I need to know?" framing. Instruct footer. |

#### `LcmSummarizeOptions` extension

```typescript
export type LcmSummarizeOptions = {
  previousSummary?: string;
  isCondensed?: boolean;
  depth?: number;           // NEW: output node depth (0=leaf, 1=d1, etc.)
  timeRange?: string;       // NEW: formatted time range for context
};
```

#### Timestamp injection in compaction

**Leaf pass** — prefix each message with its timestamp:

```typescript
// Current:
const concatenated = messageContents.map((m) => m.content).join("\n\n");

// New:
const concatenated = messageContents
  .map((m) => {
    const ts = m.createdAt ? formatTimestamp(m.createdAt) : "";
    return ts ? `[${ts}]\n${m.content}` : m.content;
  })
  .join("\n\n");
```

This requires `leafPass` to also fetch `createdAt` from messages (currently only
fetches `messageId` and `content`).

**Condensed pass** — prefix each child summary with its time range:

```typescript
// Current:
const concatenated = summaryRecords.map((s) => s.content).join("\n\n");

// New:
const concatenated = summaryRecords
  .map((s) => {
    const range = formatTimeRange(s.earliestAt, s.latestAt);
    return range ? `[${range}]\n${s.content}` : s.content;
  })
  .join("\n\n");
```

**`formatTimestamp`:** `"2026-02-17 15:37 PST"` — date, time to the minute,
timezone. Used for leaf message timestamps.

**`formatTimeRange`:** `"2026-02-17 15:37 – 17:21 PST"` or
`"2026-02-17 – 2026-02-18"` for cross-day ranges. Used for condensed child
summaries and XML `range` attribute.

Timezone is derived from the operator's configured timezone (available via
`process.env.TZ` or config). Falls back to UTC.

#### Revised prompt templates

**Leaf prompt** (depth 0):

```
You summarize a SEGMENT of an OpenClaw conversation for future model turns.
Treat this as incremental memory compaction, not a full-conversation summary.

Summary policy:
- Preserve key decisions, rationale, constraints, and active tasks.
- Keep essential technical details needed to continue work safely.
- Remove obvious repetition and conversational filler.
- Track file operations (created, modified, deleted, renamed) with paths.

{{if previousSummary}}
The model already has this preceding summary as context — focus on what is
new, changed, or resolved:

<previous_context>
{{previousSummary}}
</previous_context>
{{/if}}

Output requirements:
- Plain text only. No preamble or markdown formatting.
- Preserve timestamps for key events (decisions, completions, state changes).
- End with a line: "Expand for details about: <comma-separated list of what
  was dropped or compressed — e.g., exact commands, full error output, tool
  call sequences, verbatim config values>"
- Target length: about {{targetTokens}} tokens.

<conversation_segment>
{{sourceText}}
</conversation_segment>
```

**d1 condensed prompt** (leaves → depth 1):

```
You are compacting leaf-level conversation summaries into a condensed memory node.

You are preparing context for a fresh model instance that will continue this
conversation. The summary will be wrapped in XML with a time range attribute,
so you do NOT need to repeat the overall time span — focus on content.

{{if previousSummary}}
The model already has this preceding summary — do NOT repeat unchanged
information. Focus on what is new, changed, or resolved:

<previous_context>
{{previousSummary}}
</previous_context>
{{/if}}

Preserve:
- Decisions and their rationale (when rationale matters going forward)
- Decisions that were altered or superseded, and what replaced them
- Completed tasks with outcomes (not just "done" — what was the result?)
- Things still in progress: current state and what remains
- Blockers, open questions, and unresolved tensions
- Specific references (names, paths, URLs) that future turns will need

Drop:
- Intermediate exploration or dead ends when the conclusion is known
- Transient states that are already resolved
- Tool-internal mechanics and process scaffolding
- Verbose references when shorter forms suffice
{{if previousSummary}}
- Context that hasn't changed since previous_context
{{/if}}

Use plain text. No mandatory structure — organize however makes content clearest.
Mention sequence and causality ("after fixing X, moved to Y") but don't repeat
timestamps that will be in the XML wrapper.

End with: "Expand for details about: <list of compressed-away specifics>"

Target length: about {{targetTokens}} tokens.

<conversation_to_condense>
{{sourceText}}
</conversation_to_condense>
```

**d2 condensed prompt** (d1s → depth 2):

```
You are condensing session-level summaries into a higher-level memory node.

Each input covers a significant block of conversation. Extract the arc: what
was the goal, what happened, and what carries forward.

A future model instance reads this to understand the trajectory — not per-session
details but the overall shape of what occurred and where things stand. Time range
metadata is in the XML wrapper; don't repeat it.

Preserve:
- Decisions still in effect and their rationale
- Decisions that evolved: what changed and why
- Completed work with outcomes (not process)
- Active constraints, limitations, and known issues
- Current state of anything in progress
- Key references only if still relevant

Drop:
- Per-session operational minutiae
- Specific identifiers relevant only within a session
- Planned-then-completed items — just record the completion
- Intermediate states that a later summary supersedes
- How things were done (unless the method itself was the decision)

Use plain text. Brief section headers are fine but don't force a rigid template.

End with: "Expand for details about: <list of compressed-away specifics>"

Target length: about {{targetTokens}} tokens.

<conversation_to_condense>
{{sourceText}}
</conversation_to_condense>
```

**d3+ condensed prompt** (d2s → depth 3+):

```
You are creating a high-level memory node from phase-level summaries.

This node may persist for the entire remaining conversation. Only include what
a fresh model instance needs to pick up cold — possibly days or weeks from now.

Think: "what would I need to know?" not "what happened?"

Preserve:
- Key decisions and their rationale
- What was accomplished and its current state
- Active constraints and hard limitations
- Important relationships between people, systems, or concepts
- Lessons learned ("don't do X because Y")

Drop:
- All operational and process detail
- How things were done (only decisions and outcomes)
- Specific references unless essential for continuation
- Progress narratives (capture as current state, not history)

Use plain text. Be ruthlessly concise. Time range is in the XML wrapper.

End with: "Expand for details about: <list of compressed-away specifics>"

Target length: about {{targetTokens}} tokens.

<conversation_to_condense>
{{sourceText}}
</conversation_to_condense>
```

## Implementation

### Phase 1: Schema migration

**File:** `src/db/migration.ts`

Add `earliest_at`, `latest_at`, `descendant_count` columns to `summaries` table.
Backfill existing rows bottom-up (leaves first, then condensed by depth).

```typescript
function ensureTimeRangeColumns(db: DatabaseSync): void {
  const cols = db.prepare(`PRAGMA table_info(summaries)`).all() as SummaryColumnInfo[];
  const names = new Set(cols.map(c => c.name));
  
  if (!names.has("earliest_at")) {
    db.exec(`ALTER TABLE summaries ADD COLUMN earliest_at TEXT`);
  }
  if (!names.has("latest_at")) {
    db.exec(`ALTER TABLE summaries ADD COLUMN latest_at TEXT`);
  }
  if (!names.has("descendant_count")) {
    db.exec(`ALTER TABLE summaries ADD COLUMN descendant_count INTEGER NOT NULL DEFAULT 0`);
  }
}

function backfillTimeRanges(db: DatabaseSync): void {
  // Skip if already backfilled (check if any non-null earliest_at exists)
  const sample = db.prepare(
    `SELECT earliest_at FROM summaries WHERE earliest_at IS NOT NULL LIMIT 1`
  ).get();
  if (sample) return;

  // Leaves: derive from summary_messages → messages
  db.exec(`
    UPDATE summaries SET
      earliest_at = (
        SELECT MIN(m.created_at) FROM summary_messages sm
        JOIN messages m ON m.message_id = sm.message_id
        WHERE sm.summary_id = summaries.summary_id
      ),
      latest_at = (
        SELECT MAX(m.created_at) FROM summary_messages sm
        JOIN messages m ON m.message_id = sm.message_id
        WHERE sm.summary_id = summaries.summary_id
      ),
      descendant_count = 0
    WHERE kind = 'leaf'
  `);

  // Condensed: bottom-up by depth
  const maxDepth = (db.prepare(
    `SELECT MAX(depth) as d FROM summaries WHERE kind = 'condensed'`
  ).get() as { d: number | null })?.d ?? 0;

  for (let depth = 1; depth <= maxDepth; depth++) {
    db.exec(`
      UPDATE summaries SET
        earliest_at = (
          SELECT MIN(s2.earliest_at) FROM summary_parents sp
          JOIN summaries s2 ON s2.summary_id = sp.parent_summary_id
          WHERE sp.summary_id = summaries.summary_id
        ),
        latest_at = (
          SELECT MAX(s2.latest_at) FROM summary_parents sp
          JOIN summaries s2 ON s2.summary_id = sp.parent_summary_id
          WHERE sp.summary_id = summaries.summary_id
        ),
        descendant_count = (
          SELECT COALESCE(SUM(s2.descendant_count + 1), 0) FROM summary_parents sp
          JOIN summaries s2 ON s2.summary_id = sp.parent_summary_id
          WHERE sp.summary_id = summaries.summary_id
        )
      WHERE kind = 'condensed' AND depth = ${depth}
    `);
  }

  // Fallback: any summaries still missing earliest_at get created_at
  db.exec(`
    UPDATE summaries SET earliest_at = created_at WHERE earliest_at IS NULL;
    UPDATE summaries SET latest_at = created_at WHERE latest_at IS NULL;
  `);
}
```

**SummaryRecord type update:**

```typescript
export type SummaryRecord = {
  summaryId: string;
  conversationId: number;
  kind: SummaryKind;
  depth: number;
  content: string;
  tokenCount: number;
  fileIds: string[];
  earliestAt: Date | null;   // NEW
  latestAt: Date | null;     // NEW
  descendantCount: number;   // NEW
  createdAt: Date;
};
```

### Phase 2: Assembly format change

**File:** `src/assembler.ts`

Replace `formatSummaryContent` with XML wrapping:

```typescript
function formatTimestamp(date: Date): string {
  return date.toISOString().replace("T", " ").replace(/:\d{2}\.\d+Z$/, "");
  // → "2026-02-17 15:37"
}

function formatTimeRange(earliest: Date | null, latest: Date | null): string {
  if (!earliest || !latest) return "";
  const e = formatTimestamp(earliest);
  const l = formatTimestamp(latest);
  if (e === l) return e;
  // Same day: compress
  if (e.slice(0, 10) === l.slice(0, 10)) {
    return `${e}–${l.slice(11)}`;  // "2026-02-17 15:37–17:21"
  }
  return `${e} – ${l}`;
}

async function formatSummaryContent(
  summary: SummaryRecord,
  _summaryStore: SummaryStore,
): Promise<string> {
  const range = formatTimeRange(summary.earliestAt, summary.latestAt);
  const attrs = [
    `id="${summary.summaryId}"`,
    range ? `range="${range}"` : null,
    `depth="${summary.depth}"`,
    summary.descendantCount > 0
      ? `descendants="${summary.descendantCount}"`
      : null,
  ].filter(Boolean).join(" ");

  return `<summary ${attrs}>\n${summary.content}\n</summary>`;
}
```

**Note:** Parent summary IDs are no longer included in the presentation. They
were only useful for debugging — the model never acted on them. The `id` attribute
is sufficient for targeting `lcm_expand_query`.

### Phase 3: Depth-aware prompts

**File:** `src/summarize.ts`

1. Add `depth` and `timeRange` to `LcmSummarizeOptions`
2. Replace `buildCondensedSummaryPrompt` with `buildPromptForDepth(depth, params)`
3. Port the four prompt templates from the spec above
4. Thread `depth` from `condensedPass` through the summarize chain

```typescript
function buildPromptForDepth(params: {
  text: string;
  targetTokens: number;
  depth: number;
  previousSummary?: string;
  customInstructions?: string;
}): string {
  const { depth } = params;
  if (depth === 0) return buildLeafSummaryPrompt(params);
  if (depth === 1) return buildD1CondensedPrompt(params);
  if (depth === 2) return buildD2CondensedPrompt(params);
  return buildD3PlusCondensedPrompt(params);
}
```

### Phase 4: Timestamp injection in compaction

**File:** `src/compaction.ts`

**leafPass changes:**
1. Fetch `createdAt` alongside `messageId` and `content` for each message
2. Compute `earliestAt`/`latestAt` from message timestamps
3. Prefix each message with `[timestamp]` in concatenated text
4. Pass `depth: 0` in summarize options
5. Store `earliestAt`, `latestAt`, `descendantCount: 0` on inserted summary

**condensedPass changes:**
1. Read `earliestAt`/`latestAt`/`descendantCount` from child summary records
2. Compute parent `earliestAt`/`latestAt`/`descendantCount` from children
3. Prefix each child summary with `[time range]` in concatenated text
4. Pass `depth: targetDepth + 1` in summarize options
5. Store computed values on inserted summary

### Phase 5: SummaryStore updates

**File:** `src/store/summary-store.ts`

1. Update `insertSummary` to accept and write `earliestAt`, `latestAt`,
   `descendantCount`
2. Update `getSummary` to read and return the new columns
3. Update `CreateSummaryInput` type with optional new fields

## File change summary

| File | Changes |
|------|---------|
| `src/db/migration.ts` | Add columns, backfill migration |
| `src/store/summary-store.ts` | Types, insert, read for new columns |
| `src/assembler.ts` | XML `formatSummaryContent`, `formatTimestamp`, `formatTimeRange` |
| `src/summarize.ts` | `LcmSummarizeOptions.depth`, depth-dispatched prompts (4 variants) |
| `src/compaction.ts` | Timestamp injection in leaf/condensed pass, store new columns |
| `src/types.ts` | Update any shared types if needed |

Estimated: ~400-500 lines changed across 6 files.

## Testing

1. **Migration:** Verify backfill produces correct time ranges and descendant
   counts for existing conversation data
2. **Assembly:** Verify XML output format with all attributes populated
3. **Prompts:** Verify depth dispatch selects correct prompt variant
4. **Compaction:** Verify timestamp injection in source text, verify new columns
   populated on insert
5. **Integration:** Run full compaction cycle, verify assembled context uses XML
   format with expansion cues

## Relationship to lcm-tui

The lcm-tui already implements depth-aware prompts via Go templates
(`~/.config/lcm-tui/prompts/`). This spec ports the same prompt logic to the
TypeScript plugin for live compaction.

The prompts should remain functionally equivalent. The TUI prompts use Go
`text/template` syntax (`{{.TargetTokens}}`); the plugin uses string
interpolation. Content and structure should match.

The "expand for details about:" footer is new to both — the TUI templates should
also be updated to include this instruction.
